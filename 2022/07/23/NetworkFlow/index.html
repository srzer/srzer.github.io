<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Ruizhe Shi / Personal Site</title><meta name="author" content="Ruizhe Shi"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header id="page_header"><div class="header_wrap"><div id="blog_name"><a class="blog_title" id="site-name" href="/">Ruizhe Shi / Personal Site</a></div><button class="menus_icon"><div class="navicon"></div></button><ul class="menus_items"><li class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://scholar.google.com/citations?user=0tlXSPkAAAAJ&amp;hl=en"> Publications</a></li></ul></div></header><main id="page_main"><div class="side-card sticky"><div class="card-wrap" itemscope itemtype="http://schema.org/Person"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/profile.png'" alt="avatar"></div><div class="author-discrip"><h3>Ruizhe Shi</h3><p class="author-bio">我们从坚果剥出时间并教它走路.</p></div><div class="author-links"><button class="btn m-social-links">Links</button><ul class="social-icons"><li><a class="social-icon" href="https://twitter.com/smellycat_ZZZ" target="_blank"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="social-icon" href="https://github.com/srzer" target="_blank"><i class="fab fa-github" aria-hidden="true"></i></a></li><li><a class="social-icon" href="mailto:srz21 at mails dot tsinghua dot edu dot cn" target="_blank"><i class="fas fa-envelope" aria-hidden="true"></i></a></li></ul></div></div></div><div class="page" itemscope itemtype="http://schema.org/CreativeWork"><h2 class="page-title">网络流入门</h2><article><p>网络流研究的是有向图上的运输问题。限定：若$u\sim v$, 则$v\nsim u$. 事实上，我们可以将自环中的一条边加上点再拆成两条，从而满足限定。定义$c(u,v)$为容量，$f(u,v)$为流量。$f(u,v)\le c(u,v)$，且图满足基尔霍夫分流定律。</p>
<h2 id="残余网络"><a href="#残余网络" class="headerlink" title="残余网络"></a>残余网络</h2><p>若$u\sim v$，$c_f(u,v)&#x3D;c(u,v)-f(u,v)$</p>
<p>若$v\sim u$，$c_f(u,v)&#x3D;f(v,u)$</p>
<p>否则为0</p>
<h2 id="递增网络"><a href="#递增网络" class="headerlink" title="递增网络"></a>递增网络</h2><p>若$u\sim v$，$(f\uparrow f’)(u,v)&#x3D;f(u,v)+f’(u,v)-f’(v,u)$</p>
<p>否则为0</p>
<p>注意这里不考虑反向边了。</p>
<h3 id="引理：-f-uparrow-f’-f-f’"><a href="#引理：-f-uparrow-f’-f-f’" class="headerlink" title="引理：$|f\uparrow f’|&#x3D;|f|+|f’|$"></a>引理：$|f\uparrow f’|&#x3D;|f|+|f’|$</h3><p>$f$是G的一个流，$f’$是$G_f$的一个流。则：</p>
<ul>
<li>$f\uparrow f’$是$G$的一个流</li>
<li>其值为$|f\uparrow f’|&#x3D;|f|+|f’|$。</li>
</ul>
<p>对于流的证明只需要计算$f\uparrow f’(u,v)$的范围，并检查流量守恒即可<br>$$<br>|f\uparrow f’|&#x3D;\sum f\uparrow f’(s,u)\<br>&#x3D;\sum_{s\sim u} f(s,u)+f’(s,u)-f’(u,s)\<br>&#x3D;|f|+|f’|<br>$$</p>
<h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><p>在$G_f$中由s到t的路径称为增广路径。显然增广路径是一个流。</p>
<h2 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h2><p>对于给定流，跨越任何切割的净流量都相同，即为$|f|$。（这几乎是显然的</p>
<p>而流的值不能超过任意切割的容量（即最小容量切割</p>
<p>有如下等价：</p>
<ul>
<li>$f$是$G$的一个最大流</li>
<li>残存网络$G_f$不包括任何增广路径</li>
<li>$|f|&#x3D;c(S,T)$</li>
</ul>
<p>证明是显然的。但是$2\rightarrow 3$的构造是non-trivial的。定义$S&#x3D;{v\in V|在G_f中存在s到v的路径}$。</p>
<h2 id="Ford-Fulkerson算法"><a href="#Ford-Fulkerson算法" class="headerlink" title="Ford-Fulkerson算法"></a>Ford-Fulkerson算法</h2><ul>
<li>while循环<ul>
<li>寻找增广路径</li>
<li>更新残差网络</li>
<li>更新流量</li>
</ul>
</li>
</ul>
<p>效率在于寻找增广路径，可以dfs，bfs。</p>
<p>以及Dinic算法</p>
<h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h3><p>这部分来自<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-jiang-xie-zhi-dinic#:~:text=Dinic%E7%AE%97%E6%B3%95%EF%BC%88%E5%8F%88%E7%A7%B0Dinitz%E7%AE%97%E6%B3%95%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E6%B5%81%E7%9A%84%E5%BC%BA%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%8C%E8%AE%BE%E6%83%B3%E7%94%B1%E4%BB%A5%E8%89%B2%E5%88%97%EF%BC%88%E5%89%8D%E8%8B%8F%E8%81%94%EF%BC%89%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AE%B6Yefim%20%28Chaim%29,A.%20Dinitz%E5%9C%A81970%E5%B9%B4%E6%8F%90%E5%87%BA%E3%80%82">EK不够快？再学个Dinic吧</a></p>
<p>与EK一样，我们仍要通过bfs来判断图中是否还存在增广路，但是DInic算法里的bfs略有不同，这次，我们不用记录路径，而是给每一个点分层，对于任意点i，从s到i每多走过一个点，就让层数多一。</p>
<p>有了每个点的层数编号，对任意点u到点d的路径如果有dep[d]&#x3D;&#x3D;dep[u]+1，我们就可以判断该路径在一条<strong>最短增广路</strong>上。</p>
<p>一次bfs我们找了多条增广路！多么高效，这就是Dinic算法。</p>
<p>嗯，这几天可以试着想一想（只想，不写代码）<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/training/42162#problems">网络流24题</a>。</p>
<ul>
<li><p>n个点内部存在互斥关系或者递推关系</p>
<p>把每个点拆成两个（拆点把点权转换成边权</p>
</li>
<li><p>n个红点，m个黑点，红点匹配黑点</p>
<p>最基础的最大流</p>
</li>
<li><p>n个红点，m个黑点，选红点就必须&#x2F;不能选某些黑点</p>
<p>必须和不能都是找最小割（都是在删边）。</p>
<p>遇上费用流的时候，这里有一个“串联”的技巧：让一条流可以流多个点</p>
<p>如果这些黑点的出现次数有限定条件。。。则要求其他的性质，否则NP。</p>
</li>
</ul>
</article></div></main><div class="nav-wrap"><div class="nav"><button class="site-nav"><div class="navicon"></div></button><ul class="nav_items"><li class="nav_item"><a class="nav-page" target="_blank" rel="noopener" href="https://scholar.google.com/citations?user=0tlXSPkAAAAJ&amp;hl=en"> Publications</a></li></ul></div><div class="cd-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></div></div><footer id="page_footer"><div class="footer_wrap"><div class="copyright">&copy;2021 - 2024 by Ruizhe Shi</div><div class="theme-info">Powered by <a target="_blank" href="https://hexo.io" rel="nofollow noopener">Hexo</a> & <a target="_blank" href="https://github.com/PhosphorW/hexo-theme-academia" rel="nofollow noopener">Academia Theme</a></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-pjax@latest/jquery.pjax.min.js"></script><script src="/js/main.js"></script></body></html>